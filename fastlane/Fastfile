# This file contains the fastlane.tools configuration
# You can find the documentation at https://docs.fastlane.tools
#
# For a list of all available actions, check out
#
#     https://docs.fastlane.tools/actions
#
# For a list of all available plugins, check out
#
#     https://docs.fastlane.tools/plugins/available-plugins
#

# Uncomment the line if you want fastlane to automatically update itself
# update_fastlane

default_platform(:ios)

def is_keychain_exist(name)
  paths_to_search = [
      "~/Library/Keychains/#{name}-db",
      "~/Library/Keychains/#{name}",
      "~/Library/Keychains/#{name}.keychain-db",
      "~/Library/Keychains/#{name}.keychain",
  ].map {|path| File.expand_path path}

  paths_to_search.any? {|path| File.exist?(path)}
end

def delete_keychain_safe(name)
  begin
    delete_keychain(
        name: name
    ) if is_keychain_exist(name)
  rescue => e
    UI.important(e)
  end
end

def revert_default_keychain
  default_keychain_path = File.expand_path("~/Library/Keychains/login.keychain-db")
  sh("security list-keychains -d user -s #{default_keychain_path}", log: true)
  sh("security list-keychain", log: true)
  UI.success("Reverted default keychain")
end

def ensure_temp_keychain(name, password)
  delete_keychain_safe(name)

  create_keychain(
    name: name,
    password: password,
    unlock: true,
    timeout: 3600,
    default_keychain: true,
    lock_when_sleeps: false,
    add_to_search_list: true
  )

  if is_keychain_exist(name)
    UI.success("new keychain created")
  else
    UI.user_error!("Ð¡ould not create keychain")
    revert_default_keychain()
  end
end

def import_all_certificates(name, password)
  #register_devices(devices_file: "./fastlane/devices.txt")

  # match(
  #   type: "adhoc",
  #   app_identifier: [
  #     "my.app.identifier"
  #   ]
  # )
  # match(
  #   type: "development",
  #   app_identifier: [
  #     "my.app.identifier"
  #   ]
  # )
  # match(
  #   type: "appstore",
  #   app_identifier: [
  #     "my.app.identifier"
  #   ]
  # )

  import_certificate(
    keychain_name: name,
    keychain_password: password,
    certificate_path: "./scripts/certs/apple.cer"
  )

  import_certificate(
    keychain_name: name,
    keychain_password: password,
    certificate_path: "./scripts/certs/dev.cer"
  )
  import_certificate(
    keychain_name: name,
    keychain_password: password,
    certificate_path: "./scripts/certs/dev.p12",
    certificate_password: "12345678"      #ENV["PWD_P12"]
  )
  import_certificate(
    keychain_name: name,
    keychain_password: password,
    certificate_path: "./scripts/certs/dis.cer"
  )
  import_certificate(
    keychain_name: name,
    keychain_password: password,
    certificate_path: "./scripts/certs/dis.p12",
    certificate_password: "12345678"      #ENV["PWD_P12"]
  )
end

def import_provisioning_profiles
  install_provisioning_profile(path: "./scripts/profiles/Development.mobileprovision")
  install_provisioning_profile(path: "./scripts/profiles/AdHoc-Distribution.mobileprovision")
  install_provisioning_profile(path: "./scripts/profiles/Enterprise-Distribution.mobileprovision")
end

platform :ios do


#
# Project infos
#
workspace_name = "RXSwiftExample.xcworkspace"
project_name = "RXSwiftExample.xcodeproj"
target_name = "RXSwiftExample"
app_name = "RXSwiftExample"
app_bundle_id = "com.sicpa.test.IPSCustom"

#
# Project schemes
#
scheme_dev = "RXSwiftExample-dev"
scheme_pre_prod = "RXSwiftExample-pre-prod"
scheme_prod = "RXSwiftExample-prod"

#
# Keychains infos
#
keychain_name = "jenkins"
keychain_password = "jenkins"
keychain_path = "~/Library/Keychains/#{keychain_name}-db"

#
# Folders
#
build_folder = "./output"
test_folder = "#{build_folder}/test"
slather_output_folder = "#{build_folder}/slather_output"


  #
  # Tests
  #

  desc "Run Unit tests and UI tests"
  lane :runTests do
    scan(
      scheme: scheme_dev,
      device: "iPhone 11 Pro (14.4)",
      code_coverage: true,
      clean: true,
      skip_build: true
    )
    slather(
      scheme: scheme_dev,
      proj: project_name,
      workspace: workspace_name,
      output_directory: slather_output_folder,
      html: true,
      ignore: ["Pods/*", "ThirdParty/*", "Frameworks/*"]
    )
  end

  #
  # Local lanes
  #

  desc "Build ad-hoc app in dev environment in local machine"
  lane :build_local_dev do
    build_local(
      scheme: scheme_dev,
      export_method: "development"
    )
  end

  desc "Build ad-hoc app in pre_prod environment in local machine"
  lane :build_local_pre_prod_ad_hoc do
    build_local(
      scheme: scheme_pre_prod,
      export_method: "ad-hoc"
    )
  end

  desc "Build enterprise(in-house) app in pre-prod environment in local machine"
  lane :build_local_pre_prod_enterprise do
    build_local(
      scheme: scheme_pre_prod,
      export_method: "enterprise"
    )
  end

  desc "Build enterprise(in-house) app in prod environment in local machine"
  lane :build_local_prod_enterprise do
    build_local(
      scheme: scheme_prod,
      export_method: "enterprise"
    )
  end

  desc "Build app with :scheme and :export_method"
  private_lane :build_local do |options|
    export_method = options[:export_method]
    provisioning_type = "Development"
    if export_method == "ad-hoc"
      provisioning_type = "Ad-Hoc"
    elsif export_method == "enterprise"
      provisioning_type = "Enterprise"
    end
    gym(
      scheme: "#{options[:scheme]}",
      workspace: workspace_name,
      silent: false,
      clean: true,
      skip_profile_detection: true,
      export_method: "#{options[:export_method]}",
      export_options: {
        provisioningProfiles: {
          "#{app_bundle_id}": "com.sicpa.test.IPSCustom #{provisioning_type}"
        }
      }
    )
  end

  #
  # CI Server lanes
  #

  desc "Increment build number and commit changes to github"
  lane :increment_build_number_and_commit do
    reset_git_repo(force: true)
    ensure_git_status_clean
    build_number = increment_build_number
    commit_version_bump(message: "[skip ci] Version Bump to #{build_number}")
    push_to_git_remote
  end

  desc "Build dev and upload deploygate"
  lane :build_develop do
    prepare_materials
    gym(
      scheme: scheme_dev,
      workspace: workspace_name,
      silent: true,
      clean: true,
      skip_profile_detection: true,
      export_method: "enterprise",
      export_options: {
        provisioningProfiles: {
          "#{app_bundle_id}": "com.sicpa.test.IPSCustom Enterprise"
        }
      }
    )
    upload_DeployGate
  ensure
    clean_materials
  end

  desc "Build pre-prod Ad-Hoc"
  lane :build_pre_prod_ad_hoc do
    prepare_materials
    gym(
      scheme: scheme_pre_prod,
      workspace: workspace_name,
      silent: true,
      clean: true,
      skip_profile_detection: true,
      export_method: "ad-hoc",
      export_options: {
        signingStyle: "auto",
        provisioningProfiles: {
          "#{app_bundle_id}": "com.sicpa.test.IPSCustom Ad-Hoc"
        }
      }
    )
    upload_DeployGate
  ensure
    clean_materials
  end

  desc "Build pre-prod Enterprise"
  lane :build_pre_prod_enterprise do
    prepare_materials
    gym(
      scheme: scheme_pre_prod,
      workspace: workspace_name,
      silent: true,
      clean: true,
      skip_profile_detection: true,
      export_method: "enterprise",
      export_options: {
        provisioningProfiles: {
          "#{app_bundle_id}": "com.sicpa.test.IPSCustom Enterprise"
        }
      }
    )
    upload_DeployGate
  ensure
    clean_materials
  end

  desc "Build prod Ad-Hoc"
  lane :build_prod_ad_hoc do
    prepare_materials
    gym(
      scheme: scheme_prod,
      workspace: workspace_name,
      silent: true,
      clean: true,
      skip_profile_detection: true,
      export_method: "ad-hoc",
      export_options: {
        provisioningProfiles: {
          "#{app_bundle_id}": "com.sicpa.test.IPSCustom Ad-Hoc"
        }
      }
    )
    upload_DeployGate
  ensure
    clean_materials
  end

  desc "Build Prod Enterprise"
  lane :build_prod_enterprise do
    prepare_materials
    gym(
      scheme: scheme_prod,
      workspace: workspace_name,
      silent: true,
      clean: true,
      skip_profile_detection: true,
      export_method: "enterprise",
      export_options: {
        provisioningProfiles: {
          "#{app_bundle_id}": "com.sicpa.test.IPSCustom Enterprise"
        }
      }
    )
    upload_DeployGate
  ensure
    clean_materials
  end

  #
  # Delivery lanes
  #

  desc "Upload DeployGate"
  lane :upload_DeployGate do
    deploygate(
        api_token: "029b03c2-931f-42af-94dc-4714e96e8371",      #ENV["DEPLOYGATE_API_KEY"],
        user: "lngyeen",                                        #ENV["DEPLOYGATE_USERNAME"],
        message: "Build " + get_version_number(target: target_name) + "_" + get_build_number
    )
  end

  desc "Upload AppStore"
  lane :deliverToAppStore do
    deliver(
      submit_for_review: false,
      automatic_release: false,
      phased_release: true,
      force: true, # Skip HTMl report verification
      skip_metadata: false,
      skip_screenshots: true,
      skip_binary_upload: false
    )
  end

  desc "Slack send success"
  lane :send_slack_success do
    send_slack("Build successfully uploaded to Deploygate.", true)
  end

  desc "Slack send unstable"
  lane :send_slack_unstable do
    send_slack(message: "Build successfully uploaded to Deploygate but unstable. Unstable means test failure, code violation etc.", success: true)
  end

  desc "Slack send failure"
  lane :send_slack_failure do
    send_slack(message: "Build failure!", success: false)
  end

  #
  # Private lanes
  #

  desc "Prepare materials"
  private_lane :prepare_materials do
    ensure_temp_keychain(keychain_name, keychain_password)
    setup_jenkins(
      keychain_path: keychain_path,
      keychain_password: keychain_password
    )
    import_all_certificates(keychain_name, keychain_password)
    import_provisioning_profiles
  end

  desc "Clean materials"
  private_lane :clean_materials do
    delete_keychain_safe(keychain_name)
    revert_default_keychain
  end

  desc "Send slack"
  lane :send_slack do |options|
    slack(
      message: options[:message],
      success: options[:success],
      channel: "#personal_team",
      slack_url: "https://hooks.slack.com/services/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",
      default_payloads: [:git_branch, :last_git_commit_message],
      attachment_properties: {
        fields: [
          {
            title: "Version number",
            value: get_version_number(target: target_name),
          },
          {
            title: "Build number",
            value: get_build_number(),
          }
        ]
      }
    )
  end
end
